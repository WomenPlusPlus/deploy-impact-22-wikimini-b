"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("./error");
function default_1(bot) {
    class Page extends bot.title {
        constructor(title, namespace) {
            // bot property is set by mwn#page() method
            if (title instanceof bot.title) {
                super(title.title, title.namespace);
            }
            else {
                super(title, namespace);
            }
            this.data = {};
        }
        /**
         * @override
         */
        getTalkPage() {
            return new Page(super.getTalkPage());
        }
        /**
         * @override
         */
        getSubjectPage() {
            return new Page(super.getSubjectPage());
        }
        /**** Get operations *****/
        /** @inheritDoc */
        text() {
            return bot
                .request({
                action: 'parse',
                page: this.toString(),
                prop: 'wikitext',
            })
                .then((data) => {
                this.data.text = data.parse.wikitext;
                return data.parse.wikitext;
            });
        }
        /** @inheritDoc */
        categories() {
            return bot
                .request({
                action: 'parse',
                page: this.toString(),
                prop: 'categories',
            })
                .then((data) => data.parse.categories);
        }
        /** @inheritDoc */
        templates() {
            return bot
                .request({
                action: 'parse',
                page: this.toString(),
                prop: 'templates',
            })
                .then((data) => data.parse.templates);
        }
        /** @inheritDoc */
        links() {
            return bot
                .request({
                action: 'parse',
                page: this.toString(),
                prop: 'links',
            })
                .then((data) => data.parse.links);
        }
        /** @inheritDoc */
        backlinks() {
            return bot
                .continuedQuery({
                action: 'query',
                prop: 'linkshere',
                titles: this.toString(),
                lhprop: 'title',
                lhlimit: 'max',
            })
                .then((jsons) => {
                let pages = jsons.reduce((pages, json) => pages.concat(json.query.pages), []);
                let page = pages[0];
                if (page.missing) {
                    return Promise.reject(new error_1.MwnError.MissingPage());
                }
                return page.linkshere.map((pg) => pg.title);
            });
        }
        /** @inheritDoc */
        transclusions() {
            return bot
                .continuedQuery({
                action: 'query',
                prop: 'transcludedin',
                titles: this.toString(),
                tiprop: 'title',
                tilimit: 'max',
            })
                .then((jsons) => {
                let pages = jsons.reduce((pages, json) => pages.concat(json.query.pages), []);
                let page = pages[0];
                if (page.missing) {
                    return Promise.reject(new error_1.MwnError.MissingPage());
                }
                return page.transcludedin.map((pg) => pg.title);
            });
        }
        /** @inheritDoc */
        images() {
            return bot
                .request({
                action: 'parse',
                page: this.toString(),
                prop: 'images',
            })
                .then((data) => data.parse.images);
        }
        /** @inheritDoc */
        externallinks() {
            return bot
                .request({
                action: 'parse',
                page: this.toString(),
                prop: 'externallinks',
            })
                .then((data) => data.parse.externallinks);
        }
        /** @inheritDoc */
        subpages(options) {
            return bot
                .request({
                action: 'query',
                list: 'allpages',
                apprefix: this.title + '/',
                apnamespace: this.namespace,
                aplimit: 'max',
                ...options,
            })
                .then((data) => {
                return data.query.allpages.map((pg) => pg.title);
            });
        }
        /** @inheritDoc */
        isRedirect() {
            return this.getRedirectTarget().then((target) => {
                return this.toText() !== target;
            });
        }
        /** @inheritDoc */
        getRedirectTarget() {
            if (this.data.text) {
                let target = /^\s*#redirect \[\[(.*?)\]\]/.exec(this.data.text);
                if (!target) {
                    return Promise.resolve(this.toText());
                }
                return Promise.resolve(new bot.title(target[1]).toText());
            }
            return bot
                .request({
                action: 'query',
                titles: this.toString(),
                redirects: '1',
            })
                .then((data) => {
                let page = data.query.pages[0];
                if (page.missing) {
                    return Promise.reject(new error_1.MwnError.MissingPage());
                }
                return page.title;
            });
        }
        /** @inheritDoc */
        getCreator() {
            return bot
                .request({
                action: 'query',
                titles: this.toString(),
                prop: 'revisions',
                rvprop: 'user',
                rvlimit: 1,
                rvdir: 'newer',
            })
                .then((data) => {
                let page = data.query.pages[0];
                if (page.missing) {
                    return Promise.reject(new error_1.MwnError.MissingPage());
                }
                return page.revisions[0].user;
            });
        }
        /** @inheritDoc */
        getDeletingAdmin() {
            return bot
                .request({
                action: 'query',
                list: 'logevents',
                leaction: 'delete/delete',
                letitle: this.toString(),
                lelimit: 1,
            })
                .then((data) => {
                let logs = data.query.logevents;
                if (logs.length === 0) {
                    return null;
                }
                return logs[0].user;
            });
        }
        /** @inheritDoc */
        getDescription(customOptions) {
            // ApiParams
            return bot
                .request({
                action: 'query',
                prop: 'description',
                titles: this.toString(),
                ...customOptions,
            })
                .then((data) => {
                let page = data.query.pages[0];
                if (page.missing) {
                    return Promise.reject(new error_1.MwnError.MissingPage());
                }
                return data.query.pages[0].description;
            });
        }
        /** @inheritDoc */
        history(props, limit = 50, customOptions) {
            return bot
                .request({
                action: 'query',
                prop: 'revisions',
                titles: this.toString(),
                rvprop: props || 'ids|timestamp|flags|comment|user',
                rvlimit: limit || 50,
                ...customOptions,
            })
                .then((data) => {
                let page = data.query.pages[0];
                if (page.missing) {
                    return Promise.reject(new error_1.MwnError.MissingPage());
                }
                return data.query.pages[0].revisions;
            });
        }
        async *historyGen(props, customOptions) {
            let continuedQuery = bot.continuedQueryGen({
                action: 'query',
                prop: 'revisions',
                titles: this.toString(),
                rvprop: props || 'ids|timestamp|flags|comment|user',
                rvlimit: 50,
                ...customOptions,
            });
            for await (let json of continuedQuery) {
                for (let edit of json.query.pages[0].revisions) {
                    yield edit;
                }
            }
        }
        /** @inheritDoc */
        logs(props, limit, type, customOptions) {
            let logtypeObj = {};
            if (type) {
                logtypeObj = { [type.includes('/') ? 'leaction' : 'letype']: type };
            }
            return bot
                .request({
                action: 'query',
                list: 'logevents',
                ...logtypeObj,
                leprop: props || 'title|type|user|timestamp|comment',
                letitle: this.toString(),
                lelimit: limit || 50,
                ...customOptions,
            })
                .then((data) => {
                return data.query.logevents;
            });
        }
        async *logsGen(props, type, customOptions) {
            let logtypeObj = {};
            if (type) {
                logtypeObj = { [type.includes('/') ? 'leaction' : 'letype']: type };
            }
            let continuedQuery = bot.continuedQueryGen({
                action: 'query',
                list: 'logevents',
                ...logtypeObj,
                leprop: props || 'title|type|user|timestamp|comment',
                letitle: this.toString(),
                lelimit: 50,
                ...customOptions,
            });
            for await (let json of continuedQuery) {
                for (let event of json.query.logevents) {
                    yield event;
                }
            }
        }
        /** @inheritDoc */
        async pageViews(options = {}) {
            var _a;
            let project = (_a = bot.options.apiUrl.match(/.*\/(.*?)\.(?:org|com|net)/)) === null || _a === void 0 ? void 0 : _a[1];
            if (!project) {
                throw new Error('Invalid API URL for using pageViews(). Only Wikimedia wikis are supported.');
            }
            // Set defaults
            let { access, agent, granularity, start, end } = options;
            access = access || 'all-access';
            agent = agent || 'all-agents';
            granularity = granularity || 'monthly';
            if (granularity === 'daily') {
                let date = new bot.date();
                date.setUTCDate(date.getUTCDate() - 1);
                start = start || date;
                end = end || new bot.date();
            }
            else if (granularity === 'monthly') {
                let date = new bot.date();
                date.setUTCDate(1);
                date.setUTCMonth(date.getUTCMonth() - 1);
                start = start || date;
                end = end || new bot.date().setUTCDate(1);
            }
            let startString = new bot.date(start).format('YYYYMMDD'), endString = new bot.date(end).format('YYYYMMDD');
            return bot
                .rawRequest({
                url: `https://wikimedia.org/api/rest_v1/metrics/pageviews/per-article/${project}/${access}/${agent}/${encodeURIComponent(this.toString())}/${granularity}/${startString}/${endString}`,
                headers: {
                    'User-Agent': bot.options.userAgent,
                },
            })
                .then((response) => {
                return response.data.items;
            });
        }
        /** @inheritDoc */
        async queryAuthors() {
            let langcodematch = bot.options.apiUrl.match(/([^/]*?)\.wikipedia\.org/);
            if (!langcodematch || !langcodematch[1]) {
                throw new Error('WikiWho API is not supported for bot API URL. Re-check.');
            }
            let json;
            try {
                json = await bot
                    .rawRequest({
                    url: `https://api.wikiwho.net/${langcodematch[1]}/api/v1.0.0-beta/latest_rev_content/${encodeURIComponent(this.toString())}/?editor=true`,
                    headers: {
                        'User-Agent': bot.options.userAgent,
                    },
                })
                    .then((response) => response.data);
            }
            catch (err) {
                throw new Error(err && err.response && err.response.data && err.response.data.Error);
            }
            const tokens = Object.values(json.revisions[0])[0].tokens;
            let data = {
                totalBytes: 0,
                users: [],
            };
            let userdata = {};
            for (let token of tokens) {
                data.totalBytes += token.str.length;
                let editor = token['editor'];
                if (!userdata[editor]) {
                    userdata[editor] = { bytes: 0 };
                }
                userdata[editor].bytes += token.str.length;
                if (editor.startsWith('0|')) {
                    // IP
                    userdata[editor].name = editor.slice(2);
                }
            }
            Object.entries(userdata).map(([userid, { bytes }]) => {
                userdata[userid].percent = bytes / data.totalBytes;
                if (userdata[userid].percent < 0.02) {
                    delete userdata[userid];
                }
            });
            await bot
                .request({
                action: 'query',
                list: 'users',
                ususerids: Object.keys(userdata).filter((us) => !us.startsWith('0|')),
            })
                .then((json) => {
                json.query.users.forEach((us) => {
                    userdata[us.userid].name = us.name;
                });
            });
            data.users = Object.entries(userdata)
                .map(([userid, { bytes, name, percent }]) => {
                return {
                    id: Number(userid),
                    name: name,
                    bytes: bytes,
                    percent: percent,
                };
            })
                .sort((a, b) => {
                return a.bytes < b.bytes ? 1 : -1;
            });
            return data;
        }
        /**** Post operations *****/
        // Defined in bot.js
        edit(transform) {
            return bot.edit(this.toString(), transform);
        }
        save(text, summary, options) {
            return bot.save(this.toString(), text, summary, options);
        }
        newSection(header, message, additionalParams) {
            return bot.newSection(this.toString(), header, message, additionalParams);
        }
        move(target, summary, options) {
            return bot.move(this.toString(), target, summary, options);
        }
        delete(summary, options) {
            return bot.delete(this.toString(), summary, options);
        }
        undelete(summary, options) {
            return bot.undelete(this.toString(), summary, options);
        }
        purge(options) {
            return bot.purge(this.toString(), options);
        }
    }
    return Page;
}
exports.default = default_1;
//# sourceMappingURL=page.js.map